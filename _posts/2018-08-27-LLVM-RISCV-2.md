---
layout  : page
title   : "LLVM RISC-V #2: Global Instruction Selection"
date    : 2018-08-27
author  : "pshung"
---


# Why global instruction selection?
* Faster compile time (avoid LLVM to SelectionDAG translation phase)
* better run time performance (match complex pattern across basic blocks)
* share code between fast and optimized selection
* more modularity (divide whole instruction selection into a pipeline of passes).
[Reference:](https://2pi.dk/llvm/global-isel)

# Global Instruction Selection Passes
* addIRTranslator
* addLegalizeMachineIR
* addRegBankSelect
* addGlobalInstructionSelect

Example: a simple function takes an input argument, increment one and return

LLVM IR:
```
define i64 @inc(i64 %a)  {
  %1 = add nsw i64 %a, 1
  ret i64 %1
}
```
LLVM IR to Generic Machine Instruction (G_ADD) and Generic Virtual Register(with a size, s64, scalar 64 bits)
>llc --global-isel -march=riscv64 test.ll -o test.mir -stop-after=irtranslator

```
    %0:_(s64) = COPY $x10_64
    %1:_(s64) = G_CONSTANT i64 1
    %2:_(s64) = G_ADD %0, %1
    $x10_64 = COPY %2(s64)
    Ret implicit $x10_64
```

Legalization Generic Machine Instruction
>llc --global-isel -march=Rriscv64 test.ll -o test.mir -stop-after=legalizer

```
    %0:_(s64) = COPY $x10_64
    %1:_(s64) = G_CONSTANT i64 1
    %2:_(s64) = G_ADD %0, %1
    $x10_64 = COPY %2(s64)
    Ret implicit $x10_64

```
Choose register bank for the generic virtual registers, 'gpr' register bank for this case
>llc --global-isel -march=riscv64 test.ll -o test.mir -stop-after=regbankselect

```
    %0:gpr(s64) = COPY $x10_64
    %1:gpr(s64) = G_CONSTANT i64 1
    %2:gpr(s64) = G_ADD %0, %1
    $x10_64 = COPY %2(s64)
    Ret implicit $x10_64

```

Lower Generic machine instruction to machine instruction with target-opcode (ADDI)
>llc --global-isel -march=riscv64 test.ll -o test.s -stop-after=instruction-select

```
    %0:gpr64 = COPY $x10_64
    %2:gpr64 = ADDI %0, 1
    $x10_64 = COPY %2
    Ret implicit $x10_64

```
Generate target assembly code.
>llc --global-isel -march=riscv64 test.ll -o test.s

```
  addi  a0, a0, #1
  ret
```

